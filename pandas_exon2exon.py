'''this modue is used to extract exon-to-exon structure from the blast results'''
import pandas as pd
import os
import numpy as np
import gffutils
from collections import defaultdict


def RBHexon2exon(blastA, blastB):
    '''blast1 is the A_vs_B blast file, and the blasdt2 is the B_vs_A_blast file
    Note: 
    1) the input blast file should be filtered by the JCVI "jcvi.formats.blast best" module with "best 1" parameter 
    - the input is the absolute path, thus should be parsed carefully
    2) this function could be revised to generate the raw RBH ID datasets.'''
    nameA = blastA.split('.')[0].split('/')[1]
    blastA_maxhsp1_maxts5 = pd.read_table(blastA, index_col=False, header=None)
    blastA_maxhsp1_maxts5_ID = blastA_maxhsp1_maxts5.iloc[:, [0,1]]
    blastA_maxhsp1_maxts5_ID.columns = ['A', 'B']

    nameB = blastB.split('.')[0].split('/')[1]
    blastB_maxhsp1_maxts5 = pd.read_table(blastB, index_col=False, header=None)
    blastB_maxhsp1_maxts5_ID = blastB_maxhsp1_maxts5.iloc[:, [0,1]]
    blastB_maxhsp1_maxts5_ID.columns = ['B', 'A']

    # Merge the blast results
    AB_maxhsp1_maxts5_ID = pd.merge(blastA_maxhsp1_maxts5_ID, blastB_maxhsp1_maxts5_ID, left_on="B", right_on="B", 
                                    how = "inner", suffixes=('_A', '_B'))
    # Generate the judgements
    jud = AB_maxhsp1_maxts5_ID.iloc[:,0] == AB_maxhsp1_maxts5_ID.iloc[:,2]
    RBH_AB_maxhsp1_maxts5_ID = AB_maxhsp1_maxts5_ID[jud]
    RBH_AB_maxhsp1_maxts5_ID = RBH_AB_maxhsp1_maxts5_ID.iloc[:,[0,1]] # if using the [jud] and column indexes together (e.g. [jud].iloc[:,[0,1]]), replicates will not be removed.
    RBH_AB_maxhsp1_maxts5_ID.to_csv(f'{nameA}.{nameB}.RBHID.txt', sep='\t', header=False, index=False)
    # print(RBH_AB_maxhsp1_maxts5_ID.columns)

    # If saved the df to the workingspace, then using the combinatino of ID to read them,
    # it might be easier to handle for the function StructureJudge
    return RBH_AB_maxhsp1_maxts5_ID



def StructureJudge(nameA, nameB):
    '''this function is used to check whether the RBH exons has the exon-intron-exon structure,
    which means the corresponding transcript should have 2 exons at least.'''
    prefix = f'{nameA}.{nameB}'
    file = prefix + '.RBHID.txt'
    if 'Ped' in nameA:
        gffdatabase = gffutils.FeatureDB(f'gffdatabase/Ped.db', keep_order=True)
    else:
        gffdatabase = gffutils.FeatureDB(f'gffdatabase/{nameA}.db', keep_order=True)
    targetgene_list = []
    taretgene_freq_dict = {}
    filter_targetgene_list = []

    # Get the exon ID
    with open(file, 'r') as input:
        for line in input:
            # parsed_line = line.strip('\n').split('\t')
            targetgene_list.append(line)
    input.close()

    # Count the frequency of exon-corresponding genes
    for x in targetgene_list:
        exon_line = gffdatabase[x.strip('\n').split('\t')[0]]
        transcript_id = exon_line['Parent'][0]
        taretgene_freq_dict[transcript_id] = taretgene_freq_dict.get(transcript_id, 0) + 1

    # Filter the exon whose freq is equal to 1
    for x in targetgene_list:
        exon_id = x.strip('\n').split('\t')[0]
        exon_line = gffdatabase[exon_id]
        tmp_transcript_id = exon_line['Parent'][0]
        tmp_count = taretgene_freq_dict[tmp_transcript_id]
        # print(tmp_count)
        if tmp_count == 1:
            continue
        else:
            filter_targetgene_list.append(x)
    print(f'After filtering, there are {len(filter_targetgene_list)} exons in the dataset')
    
    # Generate the filtered RBH.txt
    with open('filter' + '.' + file, 'w') as output:
        for x in filter_targetgene_list:
            output.write(x)
    output.close()


def Getbest(path):
    '''this function is used to generate a list which contains the best blast output (generated by JCVI) '''
    bestblast_list = os.listdir(path)
    return bestblast_list

def Combination(bestblast_list):
    '''this fuction is used to generate a dict which has the key representing the species A, and the value representing the species B'''
    prefix_dict = defaultdict(list)
    for x in bestblast_list:
        seperator = '.'
        prefix1 = x.split(seperator)[0]
        prefix2 = x.split(seperator)[1]
        prefix_dict[prefix1].append(prefix2)

    return prefix_dict

def LoopRun(prefix_dict):
    for x in prefix_dict.keys():
        # The centor of RBH (main species used to blast against, in this case, the rice) should be left out.
        if len(prefix_dict[x]) >= 2:
            continue
        else:
            best1 = blastpath + '/' + x + '.' + prefix_dict[x][0] + '.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best'
            best2 = blastpath + '/' + prefix_dict[x][0] + '.' + x + '.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best'
            # print(best1)
            # print(best2)
            RBHexon2exon(best1, best2)
            StructureJudge(x, prefix_dict[x][0])


if __name__ == "__main__":
    '''Script'''
    # RBHexon2exon('Ped14.osa.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best', 'osa.Ped14.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best')
    # RBHexon2exon('Ped14.osa.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best', 'osa.Ped14.omt6.maxhsp1.maxts5.E5.id70.blast.txt.best')
    # # print(raw_RBH_df['A_A'].str.contains('\.'))
    # # print(raw_RBH_df['B'].str.contains('\.'))

    # StructureJudge('Ped14', 'osa')

    '''Serious'''
    blastpath = 'Ped14_Ped16_best'
    bestblast_list = Getbest(blastpath)
    # print(bestblast_list)
    prefix_dict = Combination(bestblast_list)
    # print(prefix_dict)
    print(prefix_dict.keys())

    # The loop below is used to run the RBHexon2exon and StructureJudge function
    LoopRun(prefix_dict)


